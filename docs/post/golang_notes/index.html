<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">

        
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" integrity="sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB" crossorigin="anonymous">

        <link href="https://fonts.googleapis.com/css?family=Ubuntu|Ubuntu+Mono" rel="stylesheet"> 

        <title>Golang notes</title>

        <link rel="stylesheet" href="https://pandysong.github.io/blog/css/stylesheet.css">
    </head>
    <body>
      <div class="container-fluid">
        <nav class="navbar navbar-expand-md navbar-light">

          
          <span class="navbar-brand mb-0 h1"></span>

          <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle Navigation" name="button">
            <span class="navbar-toggler-icon"></span>
          </button>

          <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
            <div class="navbar-nav">
              <a class="nav-item nav-link " href="https://pandysong.github.io/blog/">Home</a>
              <a class="nav-item nav-link" href="https://github.com/pandysong" target="_blank">GitHub</a>
              
              <a class="nav-item nav-link " href="https://pandysong.github.io/blog/about/">About</a>
            </div>
          </div>
        </nav>

        <section id="page-title">
          <h1><a href="https://pandysong.github.io/blog/">Pandy&#39;s Blog</a></h1>
          <span id="author-name">
            <h6><a href="https://pandysong.github.io/blog/about/">Pandy Song</a></h6>
          </span>
        </section>


<div class="blog-post">
  <h1>Golang notes</h1>
  <div class="blog-post-subheader">
    <time>28 May 2018</time>
  </div>
  <div class="blog-post-content">
    

<p>Language Spec: <a href="https://golang.org/ref/spec">https://golang.org/ref/spec</a></p>

<p>Package: <a href="https://golang.org/pkg/">https://golang.org/pkg/</a></p>

<h1 id="must-watch-1">Must watch 1</h1>

<p>Go Concurrency Patterns (slides) : <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">https://www.youtube.com/watch?v=f6kdp27TYZs</a></p>

<h2 id="goroutines">goroutines</h2>

<p>important: goroutines are not threads. They are cheap, it&rsquo;s practical to have thousands, even
hundreds of thousands of goroutines</p>

<h2 id="channels">channels</h2>

<p><code>channel sending and receving are synchronized operations</code></p>

<p>Channels are first-class types</p>

<h2 id="shared-memory">shared memory</h2>

<p><code>do not communicate via shared memory</code> using channels instead</p>

<h2 id="using-another-goroutine-to-get-the-value-to-other-two-channels-and-feed-to-one-channels">using another goroutine to get the value to other two channels and feed to one channels</h2>

<p>So that the two channels are not necessarily synchronized</p>

<p>using <code>select</code> to have only one go routine to combine two input to one channel</p>

<h2 id="we-can-send-a-channel-via-a-channel">we can send a channel via a channel</h2>

<p>Two way communications to make two goroutine synchronized</p>

<h2 id="timeout-using-select">timeout using select</h2>

<p>select {
    case s := &lt;-c:
        do_sth()
    case &lt;- time.After( time.Second):
        fmt.Println(&ldquo;You are too slow&rdquo;)
        return
}</p>

<h1 id="must-watch-2">Must watch 2</h1>

<p><a href="https://vimeo.com/53221558">https://vimeo.com/53221558</a></p>

<h1 id="section-1">Section 1</h1>

<h1 id="a-name-with-capital-letter-is-exported">A name with capital letter is exported</h1>

<h1 id="function-arguments-type-comes-after-the-variable-name">function arguments: type comes after the variable name</h1>

<h2 id="shorten-the-function-parameters">shorten the function parameters:</h2>

<p>In this example, we shortened</p>

<pre><code class="language-go">x int, y int
</code></pre>

<p>to</p>

<pre><code class="language-go">x, y int
</code></pre>

<h2 id="a-function-could-return-any-number-of-results">a function could return any number of results</h2>

<p>This is similar to Python. This is different with JavaScript.  In JavaScript, multiple result should
be shuffled into a object before returning.</p>

<pre><code class="language-go">func swap(x, y string) (string, string) {
    return y, x
}
</code></pre>

<h2 id="naked-return-and-named-return-values">naked return  and named return values</h2>

<pre><code class="language-go">
package main

import &quot;fmt&quot;

func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}

func main() {
    fmt.Println(split(17))
}

</code></pre>

<h2 id="var-statements">&lsquo;var&rsquo; statements</h2>

<h1 id="basic-types">basic types</h1>

<pre><code>bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point

float32 float64

complex64 complex128
</code></pre>

<h1 id="variable-declarations-factored-into-blocks">variable declarations factored into blocks</h1>

<h1 id="zero-values">Zero values</h1>

<p>declared without an explicit initial value are given their zero value.</p>

<p>The zero value is:</p>

<p>0 for numeric types,
   false for the boolean type, and
   &ldquo;&rdquo; (the empty string) for strings.</p>

<h1 id="fmt-printf">fmt.Printf</h1>

<p>%T for type
%v for value
%q for value with quoted</p>

<h1 id="type-conversions">type conversions</h1>

<p>Unlike in C, in Go assignment between items of different type requires an explicit conversion. Try
removing the float64 or uint conversions in the example and see what happens.</p>

<h1 id="type-inference">type inference</h1>

<p>When declaring a variable without specifying an explicit type (either by using the := syntax or var
= expression syntax), the variable&rsquo;s type is inferred from the value on the right hand side.</p>

<p>Notes:
This is like Python? Maybe not, inference means the type is deterministic when compiling</p>

<h1 id="constants">Constants</h1>

<p>Constants</p>

<p>Constants are declared like variables, but with the <code>const</code> keyword.</p>

<p>Constants can be character, string, boolean, or numeric values.</p>

<p>Constants cannot be declared using the := syntax.</p>

<p>This is different with Python, in Python constant is by convention using capital letters</p>

<h1 id="numeric-constants">Numeric Constants</h1>

<p>Numeric constants are high-precision values.</p>

<p>An untyped constant takes the type needed by its context.</p>

<h2 id="pass-by-values">Pass by values</h2>

<p>Variable is a map or slice</p>

<p>Maps and slices are reference types in Go and should be passed by values.</p>

<h1 id="section-2">Section 2</h1>

<h2 id="for">For</h2>

<p>No parentheses surrounding the three components of the for statement and braces {} are always
required.</p>

<h3 id="for-is-go-s-while">For is Go&rsquo;s &ldquo;while&rdquo;</h3>

<pre><code class="language-golang">func main() {
    sum := 1
    for sum &lt; 1000 {
        sum += sum
    }
    fmt.Println(sum)
}
</code></pre>

<h3 id="forever">Forever</h3>

<pre><code>func main() {
    for {
    }
}
</code></pre>

<h2 id="if-statement">if statement</h2>

<h3 id="if-with-a-short-statement">if with a short statement</h3>

<p>Like <code>for</code>, the <code>if</code> statement can start with a short statement to execute before the condition.</p>

<pre><code class="language-go">func pow(x, n, lim float64) float64 {
    if v := math.Pow(x, n); v &lt; lim {
        return v
    }
    return lim
}
</code></pre>

<h2 id="switch">switch</h2>

<p>A <code>switch</code> statement is a shorter way to write a sequence of if - else statements. It runs the first
case whose value is equal to the condition expression.</p>

<p>Go&rsquo;s switch is like the one in C, C++, Java, JavaScript, and PHP, except that Go only runs the
selected case, not all the cases that follow. In effect, the break statement that is needed at the
end of each case in those languages is provided automatically in Go. Another important difference is
that Go&rsquo;s switch cases need not be constants, and the values involved need not be integers.</p>

<h2 id="switch-with-no-condition">Switch with no condition</h2>

<p>Same as <code>switch true</code></p>

<h2 id="defer">Defer</h2>

<p>A defer statement defers the execution of a function until the surrounding function returns.</p>

<p>Useful example are mentioned in <a href="https://kylewbanks.com/blog/when-to-use-defer-in-go">https://kylewbanks.com/blog/when-to-use-defer-in-go</a></p>

<pre><code class="language-go">func BillCustomer(c *Customer) error {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    if err := c.Bill(); err != nil {
        return err
    }
    
    if err := c.Notify(); err != nil {
        return err
    }
    
    // ... do more stuff ...
    
    return nil
}
</code></pre>

<h1 id="section-3">Section 3</h1>

<h2 id="pointers">Pointers</h2>

<p>pointer&rsquo;s zero value is nil</p>

<p>Unlike C, Go has no pointer arithmetic</p>

<h2 id="structs">Structs</h2>

<pre><code class="language-go">type Vertex struct {
    X int
    Y int
}
</code></pre>

<h2 id="pointers-to-structs">pointers to structs</h2>

<h2 id="arrays">arrays</h2>

<pre><code>var a [10]int
</code></pre>

<p>Declares a variable a as an array of ten integers</p>

<h2 id="slices">Slices</h2>

<p>An array has a fixed size. A list on the other hand, is a dynamically-sized</p>

<p>Much like in python, but slice in go does not support stride, and negative index
But it could ignore the start index (default as 0) and end index (default as len())</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    primes := [6]int{2, 3, 5, 7, 11, 13}

    var s []int = primes[1:4]
    fmt.Println(s)
}

</code></pre>

<h3 id="like-python-slices-are-like-reference-to-arrays">Like python, Slices are like reference to arrays</h3>

<h3 id="slice-literal">slice literal</h3>

<p>A slice literal is like an array literal without the length.</p>

<p>This is an array literal:</p>

<p>[3]bool{true, true, false}</p>

<p>And this creates the same array as above, then builds a slice that references it:</p>

<p>[]bool{true, true, false}</p>

<h3 id="slice-length-vs-capacity">slice length vs capacity</h3>

<p>length: the number of elements the slice contains
capacity: the number of elements in the underlying arrays</p>

<h2 id="creating-a-slice-with-make">creating a slice with make</h2>

<p>a := make([]int, 5)  // len(a)=5</p>

<p>b := make([]int, 0, 5) // len(b)=0, cap(b)=5</p>

<pre><code>// Extend its length.
s = s[:4]
printSlice(s)

// Drop its first two values. This is interesting as it will reduce the capacity by 2
s = s[2:]
printSlice(s)
</code></pre>

<h3 id="some-article-about-array-and-slices">some article about array and slices</h3>

<p><a href="http://openmymind.net/The-Minimum-You-Need-To-Know-About-Arrays-And-Slices-In-Go/">http://openmymind.net/The-Minimum-You-Need-To-Know-About-Arrays-And-Slices-In-Go/</a></p>

<h2 id="appending-to-a-slice">Appending to a slice</h2>

<pre><code>func append(s []T, vs ...T) []T
</code></pre>

<h2 id="range-is-like-enumerate-in-python-syntax-is-a-bit-different-using-instead-of-in">range is like enumerate() in python (syntax is a bit different using <code>:=</code> instead of <code>in</code> )</h2>

<pre><code class="language-go">
package main

import &quot;fmt&quot;

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
    for i, v := range pow {
        fmt.Printf(&quot;2**%d = %d\n&quot;, i, v)
    }
}

</code></pre>

<p>if <code>i</code> is not needed, it could be replaced with <code>_</code></p>

<p>if <code>v</code> is not needed, it could be &lsquo;,v&rsquo; could be removed entirely</p>

<h2 id="maps">maps</h2>

<pre><code class="language-go">var m map[string]Vertex

func main() {
    m = make(map[string]Vertex)
    m[&quot;Bell Labs&quot;] = Vertex{
        40.68433, -74.39967,
    }
    fmt.Println(m[&quot;Bell Labs&quot;])
}
</code></pre>

<h3 id="mutating-maps">mutating maps</h3>

<p>deleting:</p>

<p>delete(m, key) is similar like in python del d[key]</p>

<h3 id="testing-if-key-is-in-map">testing if key is in map</h3>

<p>elem,ok = m[key]</p>

<p>if key is in m, ok is true. if not, ok is false.</p>

<p>if key is not in map then elem is the zero value for the map&rsquo;s element type</p>

<h3 id="strings-field-is-like-pyton-s-split">strings.Field is like Pyton&rsquo;s split()</h3>

<h2 id="function-values-like-in-python">Function values like in Python</h2>

<p>Functions are values too. They can be passed around just like other values.</p>

<p>Function values may be used as function arguments and return values.</p>

<h2 id="function-closures">Function closures</h2>

<p><a href="https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/">https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/</a></p>

<h3 id="use-cases-isolating-data">use cases: isolating data:</h3>

<p>it has similar use cases like python&rsquo;s generator function, but not flexible as generator function.
But channel in golang is like generator in Python. channel is communication between threads it is a
bit tedious to use comparing to generator which is implemented in a single thread.</p>

<p>The reason why golang has no generator is maybe because golang needs to compiled while Python is
script language which could save state in a single thread in a flexible way.</p>

<p>Note that following example is a good example how to write consice code for return the first values
in iteration.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
   z,a,b := 0,0,1
   return func() int {
         z,a, b =a, b,a+b
         return z
   }
}

func main() {
    f := fibonacci()
    for i := 0; i &lt; 10; i++ {
        fmt.Println(f())
    }
}

</code></pre>

<p>to read</p>

<p><a href="https://bbengfort.github.io/snippets/2016/12/22/yielding-functions-for-iteration-golang.html">https://bbengfort.github.io/snippets/2016/12/22/yielding-functions-for-iteration-golang.html</a></p>

<h3 id="using-function-as-function-decorator">using function as function decorator</h3>

<p>It is used to verify that a user is authenticated, log web requests, write default headers, and much
more.</p>

<h3 id="using-closure-in-sort-search">using closure in sort.Search()</h3>

<p>In following example the closure access numbers although it is never passed in</p>

<pre><code class="language-go">
package main

import (  
  &quot;fmt&quot;
  &quot;sort&quot;
)

func main() {  
  numbers := []int{1, 11, -5, 8, 2, 0, 12}
  sort.Ints(numbers)
  fmt.Println(&quot;Sorted:&quot;, numbers)

  index := sort.Search(len(numbers), func(i int) bool {
    return numbers[i] &gt;= 7
  })
  fmt.Println(&quot;The first number &gt;= 7 is at index:&quot;, index)
  fmt.Println(&quot;The first number &gt;= 7 is:&quot;, numbers[index])
}

</code></pre>

<h3 id="one-liner-to-setup-and-tear-down">one liner to setup and tear down</h3>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {  
  f = setup()
  defer f()
}

func setup() func() {  
  fmt.Println(&quot;pretend to set things up&quot;)

  return func() {
    fmt.Println(&quot;pretend to tear things down&quot;)
  }
}

</code></pre>

<h1 id="section-4">Section 4</h1>

<h2 id="methods">methods</h2>

<p>A method is a function with a special receiver argument.</p>

<p>The receiver appears in its own argument list between the func keyword and the method name.</p>

<pre><code class="language-go">func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
</code></pre>

<h3 id="pointer-receiver">Pointer receiver</h3>

<p>Note that this Scale function will receive a value as pointer. so if v is a variable of Vertex.
v.Scale(f) will compile and work.</p>

<pre><code class="language-go">func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}
</code></pre>

<p>In general, all methods on a given type should have either value or pointer receivers, but not a
mixture of both. (We&rsquo;ll see why over the next few pages.)</p>

<h2 id="interface">interface</h2>

<h3 id="interfaces-are-implemented-implicitly">Interfaces are implemented implicitly</h3>

<p>A type implements an interface by implementing its methods. There is no explicit declaration of
intent, no &ldquo;implements&rdquo; keyword.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

type I interface {
    M()
}

type T struct {
    S string
}

// This method means type T implements the interface I,
// but we don't need to explicitly declare that it does so.
func (t T) M() {
    fmt.Println(t.S)
}

func main() {
    var i I = T{&quot;hello&quot;}
    i.M()
}

</code></pre>

<p>Under the covers, interface values can be thought of as a tuple of a value and a concrete type:</p>

<p>(value, type)</p>

<p>An interface value holds a value of a specific underlying concrete type.</p>

<p>Calling a method on an interface value executes the method of the same name on its underlying type.</p>

<h3 id="interface-values-with-nil-underlying-values">Interface values with nil underlying values</h3>

<p>If the concrete value inside the interface itself is nil, the method will be called with a nil
receiver.</p>

<p>In some languages this would trigger a null pointer exception, but in Go it is common to write
methods that gracefully handle being called with a nil receiver (as with the method M in this
example.)</p>

<p>Note that an interface value that holds a nil concrete value is itself non-nil.</p>

<h3 id="nil-interface-values">Nil interface values</h3>

<p>A nil interface value holds neither value nor concrete type.</p>

<p>Calling a method on a nil interface is a run-time error because there is no type inside the
interface tuple to indicate which concrete method to call.</p>

<h3 id="the-empty-interface">The empty interface</h3>

<p>The interface type that specifies zero methods is known as the empty interface:</p>

<p>interface{}</p>

<p>An empty interface may hold values of any type. (Every type implements at least zero methods.)</p>

<p>Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes
any number of arguments of type interface{}.</p>

<pre><code class="language-go">
package main

import &quot;fmt&quot;

func main() {
    var i interface{}
    describe(i)

    i = 42
    describe(i)

    i = &quot;hello&quot;
    describe(i)
}

func describe(i interface{}) {
    fmt.Printf(&quot;(%v, %T)\n&quot;, i, i)
}

</code></pre>

<h1 id="to-read">to read</h1>

<p><a href="https://www.calhoun.io/gotchas-and-common-mistakes-with-closures-in-go/">https://www.calhoun.io/gotchas-and-common-mistakes-with-closures-in-go/</a></p>

<h1 id="type-assertions">Type assertions</h1>

<p>A type assertion provides access to an interface value&rsquo;s underlying concrete value.</p>

<p>t := i.(T)</p>

<p>This statement asserts that the interface value i holds the concrete type T and assigns the
underlying T value to the variable t.</p>

<p>If i does not hold a T, the statement will trigger a panic.</p>

<p>To test whether an interface value holds a specific type, a type assertion can return two values:
the underlying value and a boolean value that reports whether the assertion succeeded.</p>

<p>t, ok := i.(T)</p>

<p>If i holds a T, then t will be the underlying value and ok will be true.</p>

<p>If not, ok will be false and t will be the zero value of type T, and no panic occurs.</p>

<p>Note the similarity between this syntax and that of reading from a map.</p>

<h1 id="type-switches">type switches</h1>

<pre><code class="language-go">
switch v := i.(type) {
case T:
    // here v has type T
case S:
    // here v has type S
default:
    // no match; here v has the same type as i
}

</code></pre>

<h1 id="errors">Errors</h1>

<pre><code class="language-go">func (e ErrNegativeSqrt) Error() string
</code></pre>

<h1 id="readers">Readers</h1>

<p>The io.Reader interface has a Read method:</p>

<p>func (T) Read(b []byte) (n int, err error)</p>

<h1 id="section-5">Section 5</h1>

<p><a href="https://tour.golang.org/concurrency/1">https://tour.golang.org/concurrency/1</a></p>

<h2 id="goroutines-1">goroutines</h2>

<p>Goroutines</p>

<p>A goroutine is a lightweight thread managed by the Go runtime.</p>

<p>go f(x, y, z)
starts a new goroutine running</p>

<p>f(x, y, z)</p>

<p>The evaluation of f, x, y, and z happens in the current goroutine and the execution of f happens in
the new goroutine.</p>

<h2 id="channels-1">Channels</h2>

<p>Channels are a typed conduit through which you can send and receive values with the channel
operator, &lt;-.</p>

<p>ch &lt;- v    // Send v to channel ch.
v := &lt;-ch  // Receive from ch, and
           // assign value to v.</p>

<p>(The data flows in the direction of the arrow.)</p>

<p>Like maps and slices, channels must be created before use:</p>

<p>ch := make(chan int)</p>

<p>By default, sends and receives block until the other side is ready. This allows goroutines to
synchronize without explicit locks or condition variables.</p>

<p>The example code sums the numbers in a slice, distributing the work between two goroutines. Once
both goroutines have completed their computation, it calculates the final result.</p>

<h3 id="buffered-channels">Buffered Channels</h3>

<p>Channels can be buffered. Provide the buffer length as the second argument to make to initialize a
buffered channel:</p>

<p>ch := make(chan int, 100)</p>

<h3 id="range-and-close">Range and close</h3>

<p>A sender can close a channel to indicate that no more values will be sent. Receivers can test
whether a channel has been closed by assigning a second parameter to the receive expression: after</p>

<p>v, ok := &lt;-ch</p>

<p>ok is false if there are no more values to receive and the channel is closed.</p>

<p>The loop for i := range c receives values from the channel repeatedly until it is closed.</p>

<p>Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will
cause a panic.</p>

<p>Another note: Channels aren&rsquo;t like files; you don&rsquo;t usually need to close them. Closing is only
necessary when the receiver must be told there are no more values coming, such as to terminate a
range loop.</p>

<h2 id="select">Select</h2>

<p>Following example using two channels to communicate between two threads.</p>

<pre><code class="language-go">package main

import &quot;fmt&quot;

func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c &lt;- x:
            x, y = y, x+y
        case &lt;-quit:
            fmt.Println(&quot;quit&quot;)
            return
        }
    }
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go func() {
        for i := 0; i &lt; 10; i++ {
            fmt.Println(&lt;-c)
        }
        quit &lt;- 0
    }()
    fibonacci(c, quit)
}

</code></pre>

<p>In this example, the reason why the receiver is running in a thread is because the sender may need
some time to tear down before main exits</p>

<h3 id="default-selection">default selection</h3>

<pre><code class="language-go">)ckage main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    tick := time.Tick(100 * time.Millisecond)
    boom := time.After(500 * time.Millisecond)
    for {
        select {
        case &lt;-tick:
            fmt.Println(&quot;tick.&quot;)
        case &lt;-boom:
            fmt.Println(&quot;BOOM!&quot;)
            return
        default:
            fmt.Println(&quot;    .&quot;)
            time.Sleep(50 * time.Millisecond)
        }
    }
}

</code></pre>

<h2 id="sync-mutex">sync.Mutex</h2>

<p>type Mutex</p>

<p>A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex.</p>

<p>So user could directly using the Lock() and Unlock()</p>

  </div>
</div>

      <footer>
        <hr>
        <small>
          &copy; 2019 Pandy Song.
          Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> using the <a href="https://github.com/arjunkrishnababu96/basics" target="_blank">Basics</a> theme.
        </small>
      </footer>
    </div> 

    
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js" integrity="sha384-smHYKdLADwkXOn1EmN1qk/HfnUcbVRZyYmZ4qpPea6sjB/pTJ0euyQp0Mk8ck+5T" crossorigin="anonymous"></script>
  </body>
</html>

